/*****************************************************************************************
**                                                                                      **
** Copyright (C) Infineon Technologies (2014)                                           **
**                                                                                      **
** All rights reserved.                                                                 **
**                                                                                      **
** This document contains proprietary information belonging to Infineon                 **
** Technologies. Passing on and copying of this document, and communication             **
** of its contents is not permitted without prior written authorization.                **
**                                                                                      **
** THE SOURCE CODE AND DOCUMENTATION MAY INCLUDE ERRORS. INFINEON TECHNOLOGIES          **
** RESERVES THE RIGHT TO INCORPORATE MODIFICATIONS TO THE SOURCE CODE IN LATER          **
** REVISIONS OF IT, AND TO MAKE IMPROVEMENTS OR CHANGES IN THE DOCUMENTATION OR         **
** THE PRODUCTS OR TECHNOLOGIES DESCRIBED THEREIN AT ANY TIME.                          **
**                                                                                      **
** INFINEON TECHNOLOGIES SHALL NOT BE LIABLE FOR ANY DIRECT, INDIRECT OR                **
** CONSEQUENTIAL DAMAGE OR LIABILITY ARISING FROM YOUR USE OF THE SOURCE CODE OR        **
** ANY DOCUMENTATION, INCLUDING BUT NOT LIMITED TO, LOST REVENUES, DATA OR              **
** PROFITS, DAMAGES OF ANY SPECIAL, INCIDENTAL OR CONSEQUENTIAL NATURE, PUNITIVE        **
** DAMAGES, LOSS OF PROPERTY OR LOSS OF PROFITS ARISING OUT OF OR IN CONNECTION         **
** WITH THIS AGREEMENT, OR BEING UNUSABLE, EVEN IF ADVISED OF THE POSSIBILITY OR        **
** PROBABILITY OF SUCH DAMAGES AND WHETHER A CLAIM FOR SUCH DAMAGE IS BASED UPON        **
** WARRANTY, CONTRACT, TORT, NEGLIGENCE OR OTHERWISE.                                   **
**                                                                                      **
******************************************************************************************/

#define OS_COMMON_GLOBALS
#include "TestHsm.h"

typedef enum
{
    NO_TEST      = (0) ,
    SYSTICK_TEST = (1) ,
    TRNG_TEST    = (2) ,
    AES_CBC      = (3) ,
    AES_ECB      = (4) ,
    ALL_TESTS    = (55)
} TestHsm_id;
#define TEST_EMUCTRLCIPHERDEMO 0
#define EMUCTRL_MAC_HSMSFR_ADDR_CHECK 0
/*****************************************************************************************
**                                                                                      **
*****************************************************************************************/
#define CRY_START_SEC_CONST_UNSPECIFIED
#include "Cry_MemMap.h"

const Csm_SymKeyType TestKey_2 = {1, {CRY_HSM_KEY_2}};
const Csm_SymKeyType TestKey_3 = {1, {CRY_HSM_KEY_3}};
const Csm_SymKeyType TestKey_4 = {1, {CRY_HSM_KEY_4}};
const Csm_SymKeyType TestKey_12 = {1, {CRY_HSM_KEY_12}};
const Csm_SymKeyType TestKey_5 = {1, {CRY_HSM_KEY_5}};
const Csm_SymKeyType TestKey_7 = {1, {CRY_HSM_KEY_7}};
const Csm_SymKeyType TestKey_RAM = {1, {CRY_HSM_RAM_KEY}};
#if ITF
const Csm_SymKeyType TestKey_100 = {1, {100}};
#endif
const uint8 TEST_CONST_L[16] = {
    0x7d, 0xf7, 0x6b, 0x0c, 0x1a, 0xb8, 0x99, 0xb3,
    0x3e, 0x42, 0xf0, 0x47, 0xb9, 0x1b, 0x54, 0x6f
};

#if EMUCTRL_MAC_HSMSFR_ADDR_CHECK
const HsmAes_Block const Test_Hsm_InAddrChk_Msg[4]=
{
        {{ 0xe2bec16b , 0x969f402e , 0x117e3de9 , 0x2a179373}},
        {{ 0x578a2dae , 0x9cac031e , 0xac6fb79e , 0x518eaf45}},
        {{ 0x461cc830 , 0x11e45ca3 , 0x19c1fbe5 , 0xef520a1a}},
        {{ 0x45249ff6 , 0x179b4fdf , 0x7b412bad , 0x10376ce6}}
};
const HsmAes_Block TEST_CONST_MAC16_HsmAddrChk = {
        {0xb4160a07,0x44414d6b,0x9ddd9bf7,0x7c284ad0}
};
#endif
const uint8 TEST_CONST_KEY1[16] = {
    0xfb, 0xee, 0xd6, 0x18, 0x35, 0x71, 0x33, 0x66,
    0x7c, 0x85, 0xe0, 0x8f, 0x72, 0x36, 0xa8, 0xde
};

const uint8 TEST_CONST_KEY2[16] = {
    0xf7, 0xdd, 0xac, 0x30, 0x6a, 0xe2, 0x66, 0xcc,
    0xf9, 0x0b, 0xc1, 0x1e, 0xe4, 0x6d, 0x51, 0x3b
};

const uint8 TEST_CONST_MAC0[16] = {
    0xbb, 0x1d, 0x69, 0x29, 0xe9, 0x59, 0x37, 0x28,
    0x7f, 0xa3, 0x7d, 0x12, 0x9b, 0x75, 0x67, 0x46
};

const uint8 TEST_CONST_MAC16[16] = {
    0x07, 0x0a, 0x16, 0xb4, 0x6b, 0x4d, 0x41, 0x44,
    0xf7, 0x9b, 0xdd, 0x9d, 0xd0, 0x4a, 0x28, 0x7c
};
const uint8 TEST_CONST_MAC40[16] = {
    0xdf, 0xa6, 0x67, 0x47, 0xde, 0x9a, 0xe6, 0x30,
    0x30, 0xca, 0x32, 0x61, 0x14, 0x97, 0xc8, 0x27
};

const uint8 TEST_CONST_MAC21[16] = {
    0xab, 0xa7, 0x2d, 0xa5, 0x6c, 0xf4, 0xb1, 0x49,
    0x88, 0xe3, 0xf2, 0x1f, 0x6e, 0x77, 0x5d, 0xb3
};

const uint8 TEST_CONST_MAC22[16] = {
    0x6e, 0x95, 0x4c, 0x65, 0x9f, 0x23, 0x4c, 0x00,
    0x51, 0xff, 0x22, 0x58, 0x4f, 0x3b, 0x73, 0x7f
};

const uint8 TEST_CONST_MAC18[4] = {
    0x0d, 0xcb, 0xaf, 0xc9
};

const uint8 TEST_CONST_MAC23[16] = {
    0x6e, 0x95, 0x4c, 0x65, 0x9f, 0x23, 0x4c, 0x00,
    0x51, 0xff, 0x22, 0x58, 0x4f, 0x3b, 0x73, 0x7f
};

const uint8 TEST_CONST_MAC64[16] = {
    0x51, 0xf0, 0xbe, 0xbf, 0x7e, 0x3b, 0x9d, 0x92,
    0xfc, 0x49, 0x74, 0x17, 0x79, 0x36, 0x3c, 0xfe
};

const uint8 TEST_CONST_PLAIN[64] = {
    0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
    0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
    0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
    0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
    0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
    0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
    0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
    0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
};
const uint8 TEST_CONST_PLAIN_1[16] = {
    0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
    0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a};

const uint8 TEST_CONST_PLAIN_GCM[10] = {
    0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
    0xe9, 0x3d};
const uint8 TEST_CONST_PLAIN_2[16] = {
        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
            0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51
};
const uint8 TEST_CONST_PLAIN_3[16] = {
        0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
            0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
};
const uint8 TEST_CONST_PLAIN_4[16] = {
        0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
            0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
};
const uint8 TEST_CONST_PLAIN_48 [48] = {
        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
        0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
        0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
        0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
        0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
        0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10

};

const uint8 TEST_CONST_PLAIN_32 [32] = {
        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
       0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
       0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
       0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,

};
const uint8 TEST_CONST_KEY[16] = {
    0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
    0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
};

const uint8 TEST_CONST_INIT_VEC[16] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
};

const uint8 TEST_GCM_CONST_INIT_VEC[12] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b};


const uint8 TEST_CONST_ECB_CIPH[16] = {
    0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60,
    0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97
};

const uint8 TEST_CONST_CBC_CIPH[64] = {
    0x76, 0x49, 0xab, 0xac, 0x81, 0x19, 0xb2, 0x46,
    0xce, 0xe9, 0x8e, 0x9b, 0x12, 0xe9, 0x19, 0x7d,
    0x50, 0x86, 0xcb, 0x9b, 0x50, 0x72, 0x19, 0xee,
    0x95, 0xdb, 0x11, 0x3a, 0x91, 0x76, 0x78, 0xb2,
    0x73, 0xbe, 0xd6, 0xb8, 0xe3, 0xc1, 0x74, 0x3b,
    0x71, 0x16, 0xe6, 0x9e, 0x22, 0x22, 0x95, 0x16,
    0x3f, 0xf1, 0xca, 0xa1, 0x68, 0x1f, 0xac, 0x09,
    0x12, 0x0e, 0xca, 0x30, 0x75, 0x86, 0xe1, 0xa7
};

const uint8 TEST_CONST_XTS_CIPH[64] = {
    0x76, 0x49, 0xab, 0xac, 0x81, 0x19, 0xb2, 0x46,
    0xce, 0xe9, 0x8e, 0x9b, 0x12, 0xe9, 0x19, 0x7d,
    0x50, 0x86, 0xcb, 0x9b, 0x50, 0x72, 0x19, 0xee,
    0x95, 0xdb, 0x11, 0x3a, 0x91, 0x76, 0x78, 0xb2,
    0x73, 0xbe, 0xd6, 0xb8, 0xe3, 0xc1, 0x74, 0x3b,
    0x71, 0x16, 0xe6, 0x9e, 0x22, 0x22, 0x95, 0x16,
    0x3f, 0xf1, 0xca, 0xa1, 0x68, 0x1f, 0xac, 0x09,
    0x12, 0x0e, 0xca, 0x30, 0x75, 0x86, 0xe1, 0xa7
};



const uint8 TEST_CONST_CTR_CIPH[64] = {
    0x3b,0x3f,0xd9,0x2e, 0xb7,0x2d,0xad,0x20,
    0x33,0x34,0x49,0xf8, 0xe8,0x3c,0xfb,0x4a,
    0x01,0x0c,0x04,0x19, 0x99,0xe0,0x3f,0x36,
    0x44,0x86,0x24,0x48, 0x3e,0x58,0x2d,0x0e,
    0xa6,0x22,0x93,0xcf, 0xa6,0xdf,0x74,0x53,
    0x5c,0x35,0x41,0x81, 0x16,0x87,0x74,0xdf,
    0x2d,0x55,0xa5,0x47, 0x06,0x27,0x3c,0x50,
    0xd7,0xb4,0xf8,0xa8, 0xcd,0xdc,0x6e,0xd7
};

const uint8 TEST_CONST_OFB_CIPH[64] = {
    0x3b,0x3f,0xd9,0x2e, 0xb7,0x2d,0xad,0x20,
    0x33,0x34,0x49,0xf8, 0xe8,0x3c,0xfb,0x4a,
    0x77,0x89,0x50,0x8d, 0x16,0x91,0x8f,0x03,
    0xf5,0x3c,0x52,0xda, 0xc5,0x4e,0xd8,0x25,
    0x97,0x40,0x05,0x1e, 0x9c,0x5f,0xec,0xf6,
    0x43,0x44,0xf7,0xa8, 0x22,0x60,0xed,0xcc,
    0x30,0x4c,0x65,0x28, 0xf6,0x59,0xc7,0x78,
    0x66,0xa5,0x10,0xd9, 0xc1,0xd6,0xae,0x5e
};

const uint8 TEST_CONST_CFB_CIPH[64] = {
    0x3b,0x3f,0xd9,0x2e, 0xb7,0x2d,0xad,0x20,
    0x33,0x34,0x49,0xf8, 0xe8,0x3c,0xfb,0x4a,
    0xc8,0xa6,0x45,0x37, 0xa0,0xb3,0xa9,0x3f,
    0xcd,0xe3,0xcd,0xad, 0x9f,0x1c,0xe5,0x8b,
    0x26,0x75,0x1f,0x67, 0xa3,0xcb,0xb1,0x40,
    0xb1,0x80,0x8c,0xf1, 0x87,0xa4,0xf4,0xdf,
    0xc0,0x4b,0x05,0x35, 0x7c,0x5d,0x1c,0x0e,
    0xea,0xc4,0xc6,0x6f, 0x9f,0xf7,0xf2,0xe6
};



const uint8 TEST_CONST_MIYAGUCHI_PRENEEL[16] = {
    0xc7, 0x27, 0x7a, 0x0d, 0xc1, 0xfb, 0x85, 0x3b,
    0x5f, 0x4d, 0x9c, 0xbd, 0x26, 0xbe, 0x40, 0xc6
};

const uint8 TEST_CONST_RANDOM_SEED[16] = {
    0x41, 0xf2, 0x12, 0x13, 0xbc, 0xa0, 0x43, 0x4b,
    0x3e, 0xb3, 0xba, 0xfc, 0xb0, 0xa1, 0x9d, 0x74
};

const uint8 TEST_CONST_RANDOM_NUMBER[16] = {
    0x61, 0x4a, 0xae, 0x8a, 0x7b, 0xb8, 0xff, 0xf3,
    0x1a, 0xc3, 0x23, 0x0e, 0x62, 0x40, 0x50, 0x6b
};

const uint8 TEST_CONST_RANDOM_ENTROPY[16] = {
    0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
    0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51
};

const uint8 TEST_CONST_KEY_UPDATE_M1[16] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x41
};

const uint8 TEST_CONST_CHALLENGE_BYTES[16] = {
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x00
};

/*64 bytes
const uint32 TEST_CONST_GCM_PLAIN_TEXT[16] = {
0x253231d9,0xe50684f8,0xc50959a5,0x9a26f5af,
0x53a9a786,0xdaf73415,0x3d304c2e,0x728a318a,
0x950c3c1c,0x53096895,0x2403cf2f,0x25b5a649,
0xf5ed6ab1,0x57e60daa,0x397b63ba,0x55d2af1a
};*/

/*60 bytes*/
const uint32 TEST_CONST_GCM_PLAIN_TEXT[15] = {
0x253231d9,0xe50684f8,0xc50959a5,0x9a26f5af,
0x53a9a786,0xdaf73415,0x3d304c2e,0x728a318a,
0x950c3c1c,0x53096895,0x240ecf2f,0x25b5a649,
0xf5ed6ab1,0x57e60daa,0x397b63ba};

/*32 bytes*/
const uint32 TEST_CONST_GCM_PLAIN_TEXT_32BYTES[8] =
{0x253231d9,0xe50684f8,0xc50959a5,0x9a26f5af,
 0x53a9a786,0xdaf73415,0x3d304c2e,0x728a318a
};
/*28 bytes : non multiple of 16*/
const uint32 TEST_CONST_GCM_PLAIN_TEXT_28BYTES[7] =
{
  0x950c3c1c,0x53096895,0x240ecf2f,0x25b5a649,
  0xf5ed6ab1,0x57e60daa,0x397b63ba
};

#if(TEST_EMUCTRLCIPHERDEMO == 1)
const uint8 Host_EcbEncPlainTextBlock[16] = {
     0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
     0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
};

const uint8 Host_EcbDecCipherTextBlock[16] =
{
  0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30,
  0xd8, 0xcd, 0xb7, 0x80, 0x70, 0xb4, 0xc5, 0x5a
};

const uint8 Host_CbcEncPlainTextBlock[64] =
{
  0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
  0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
  0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
  0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
  0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
  0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
  0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
  0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10

};

const uint8 Host_CbcDecCipherTextBlock[64] =
{
  0x76, 0x49, 0xab, 0xac, 0x81, 0x19, 0xb2, 0x46,
  0xce, 0xe9, 0x8e, 0x9b, 0x12, 0xe9, 0x19, 0x7d,
  0x50, 0x86, 0xcb, 0x9b, 0x50, 0x72, 0x19, 0xee,
  0x95, 0xdb, 0x11, 0x3a, 0x91, 0x76, 0x78, 0xb2,
  0x73, 0xbe, 0xd6, 0xb8, 0xe3, 0xc1, 0x74, 0x3b,
  0x71, 0x16, 0xe6, 0x9e, 0x22, 0x22, 0x95, 0x16,
  0x3f, 0xf1, 0xca, 0xa1, 0x68, 0x1f, 0xac, 0x09,
  0x12, 0x0e, 0xca, 0x30, 0x75, 0x86, 0xe1, 0xa7
};

const uint8 Host_InitVectorBlock[16] = {
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
};

const uint8 *Host_EcbEncPlainTextBlockPtr;
const uint8 *Host_EcbDecCipherTextBlockPtr;
const uint8 *Host_CbcEncPlainTextBlockPtr;
const uint8 *Host_CbcDecCipherTextBlockPtr;
const uint8 *Host_InitVectorBlockPtr;
#endif

#define CRY_STOP_SEC_CONST_UNSPECIFIED
#include "Cry_MemMap.h"

#define CRY_START_SEC_VAR_INIT_UNSPECIFIED
#include "Cry_MemMap.h"

TestHsm_id testToRun = ALL_TESTS; /* <=== Select the Test */
uint8 TEST_CONST_MAC22_2[12] = {
    0x6e, 0x95, 0x4c, 0x65, 0x9f, 0x23, 0x4c, 0x00,
    0x51, 0xff, 0x22, 0x58};
#define CRY_STOP_SEC_VAR_INIT_UNSPECIFIED
#include "Cry_MemMap.h"

#define CRY_START_SEC_VAR_UNSPECIFIED
#include "Cry_MemMap.h"

uint8 TrngSeed[16] = {0};
volatile uint32 g_TestCount = 0;
uint32 TEST_HSM_BUF_TEMP_A[TEST_CRYPT_SIZE/4];
uint32 TEST_HSM_BUF_TEMP_B[TEST_CRYPT_SIZE/4];
uint32 TEST_HSM_BUF_TEMP_C[4];
uint32 TEST_HSM_BUF_TEMP_D[4];
uint32 TEST_HSM_BUF_TEMP_F[4];
uint32 TEST_HSM_BUF_TEMP_G[4];
uint32 TEST_HSM_BUF_TEMP_H[8];
uint32 TEST_HSM_BUF_TEMP_I[16];
uint32 TEST_HSM_BUF_TEMP_J[16];
uint8 TEST_HSM_BUF_TEMP_SREG[4];
uint8 Test_Hsm_TempMacBuf[32];
uint8 Test_Hsm_TempUIDBuf[16];
uint8 Test_Hsm_TempMainMacBuf[16];
uint8 Test_Hsm_TempGenMacBuf[16];
uint8 Test_Hsm_TempSregBuf[4];
uint8 Test_Hsm_TempGcmAuthTag[16];
uint8 Test_XTSEncOutput25Bytes[25];
uint8 Test_XTSDecOutput25Bytes[25];
uint32 TEST_CONST_GCM_CIPHER_TXT[15];
uint32 TEST_CONST_GCM_CIPHER_TXT_32BYTES[8];
uint32 TEST_CONST_GCM_CIPHER_TXT_28BYTES[7];
uint32 TEST_CONST_GCM_PLN_32BYTES[8];
uint32 TEST_CONST_GCM_PLN_28BYTES[7];
uint32 TEST_GCM_DEC_PLAIN_TXT[15];
Csm_VerifyResultType AuthTagResultPtr;



#if(TEST_EMUCTRLCIPHERDEMO == 1)
uint8 Host_EcbTextOutData[16] = {
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
uint8 Host_CbcTextOutData[64] = {
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
uint8 *Host_EcbTextOutDataPtr;
uint8 *Host_CbcTextOutDataPtr;
#endif

#if EMUCTRL_MAC_HSMSFR_ADDR_CHECK
HsmAes_Block Test_Hsm_OutAddrChk_Msg;

HsmAes_Block TEST_CONST_INVMAC16_HsmAddrChk = {{~0xb4160a07,~0x44414d6b,~0x9ddd9bf7,~0x7c284ad0}};
uint8 SafeMac_HSMADDR_CHK[24];
/* Host2Hsm_SafeVerifyResultType SafeMac_HSMADDR_CHK; */

uint32 VerResult_HsmAddrChk;

volatile HsmAes_Block const *Test_Hsm_InAddrChk_Msg_Ptr;

volatile HsmAes_Block *Test_Hsm_OutAddrChk_Msg_Ptr;

volatile HsmAes_Block *MAC16_HsmAddressCheck;

volatile uint8 *SafeMac_HSMADDR_CHK_Ptr;

volatile HsmAes_Block *TEST_CONST_MAC16_HsmAddrChk_Ptr;

volatile uint32 *VerResult_HsmAddrChk_Ptr;
#endif


uint32 HsmSheCancelFlag ;
uint32 ISR_HsmStatus;
boolean CancelRequired = 0;

#define CRY_STOP_SEC_VAR_UNSPECIFIED
#include "Cry_MemMap.h"
/*************************************************************************************//**
 * Execution of all tests
*//**************************************************************************************/

#define CRY_START_SEC_CODE
/*IFX_MISRA_RULE_20_01_STATUS=File inclusion after pre-processor directives is
 allowed only for Cry_MemMap.h*/
#include "Cry_MemMap.h"
void TestHsm_step(void)
{
    static boolean isVirgin = TRUE;

    /*boolean initBaseKeys = isVirgin;*/
    if (isVirgin == TRUE)
    {
        TestHsm_initializeStandardKeys();
        isVirgin = FALSE;
    }
#if EMUCTRL_MAC_HSMSFR_ADDR_CHECK
    if(Test_Hsm_InAddrChk_Msg_Ptr != NULL_PTR)
    {
        Test_Hsm_InAddrChk_Msg_Ptr = (HsmAes_Block*)&Test_Hsm_InAddrChk_Msg;
    }
    if(Test_Hsm_OutAddrChk_Msg_Ptr != NULL_PTR)
    {
        Test_Hsm_OutAddrChk_Msg_Ptr = (HsmAes_Block*)&Test_Hsm_OutAddrChk_Msg;
    }
    if(TEST_CONST_MAC16_HsmAddrChk_Ptr != NULL_PTR)
    {
        TEST_CONST_MAC16_HsmAddrChk_Ptr = (HsmAes_Block*)&TEST_CONST_MAC16_HsmAddrChk;
    }
    if(SafeMac_HSMADDR_CHK_Ptr != NULL_PTR)
    {
        SafeMac_HSMADDR_CHK_Ptr = (uint8 *)&SafeMac_HSMADDR_CHK;
    }
    if(VerResult_HsmAddrChk_Ptr != NULL_PTR)
    {
        VerResult_HsmAddrChk_Ptr = &VerResult_HsmAddrChk;
    }
    if(TEST_CONST_MAC16_HsmAddrChk_Ptr != NULL_PTR)
    {
        TEST_CONST_MAC16_HsmAddrChk_Ptr = &TEST_CONST_INVMAC16_HsmAddrChk;
    }
#endif

    #if(TEST_EMUCTRLCIPHERDEMO == 1)
    if(Host_EcbEncPlainTextBlockPtr != NULL_PTR )
    {
      Host_EcbEncPlainTextBlockPtr = Host_EcbEncPlainTextBlock;
    }
    if(Host_EcbDecCipherTextBlockPtr != NULL_PTR )
    {
      Host_EcbDecCipherTextBlockPtr = Host_EcbDecCipherTextBlock;
    }
    if(Host_CbcEncPlainTextBlockPtr != NULL_PTR )
    {
      Host_CbcEncPlainTextBlockPtr = Host_CbcEncPlainTextBlock;
    }
    if(Host_CbcDecCipherTextBlockPtr != NULL_PTR )
    {
        Host_CbcDecCipherTextBlockPtr = Host_CbcDecCipherTextBlock;
    }
    if(Host_EcbTextOutDataPtr != NULL_PTR )
    {
        Host_EcbTextOutDataPtr = Host_EcbTextOutData;
    }
    if(Host_CbcTextOutDataPtr != NULL_PTR )
    {
        Host_CbcTextOutDataPtr = Host_CbcTextOutData;
    }
    if(Host_InitVectorBlockPtr != NULL_PTR )
    {
        Host_InitVectorBlockPtr = Host_InitVectorBlock;
    }    
    #endif

	/*generate mac with key slot12*/
    TestHsm_generate_mac();
	/*verify mac with key slot5*/
    TestHsm_verify_mac();
	/*aes ecb with ram key*/
    TestHsm_aes_ecb();
    TestHsm_random();
	/*generate mac with ram key*/
    TestHsm_generate_mac_Ram();
	/*verify mac with ram key*/
    TestHsm_verify_mac_Ram();
	/*aes ecb with key slot7*/
    TestHsm_aes_ecb_reference_FlashKey();
 /*   TestHsm_key(initBaseKeys);
    TestHsm_mac_timing(); */


    g_TestCount = g_TestCount + 1U;

}


/*****************************************************************************************
**                                                                                      **
*****************************************************************************************/
void print_hex(const char *str, const void *data, int len)
{
    const uint8 *buf = data;
    int i;

    for (i = 0; i < len; i++)
    {
        if (((i % 16) == 0) && (i != 0))
        {
            print_f(str);
        }
        print_f("%02x", buf[i]);
        if ((i % 4) == 3)
        {
            print_f(" ");
        }
        if ((i % 16) == 15)
        {
            print_f("\n");
        }
    }
    if ((i % 16) != 0)
    {
        print_f("\n");
    }
}

/*****************************************************************************************
**                                                                                      **
*****************************************************************************************/
void print128(const void *data)
{
    const uint8 *bytes = (const uint8 *)data;
    int j;

    for (j = 0; j < 16; j++)
    {
        print_f("%02x", bytes[j]);
        if ((j % 4) == 3)
        {
            print_f(" ");
        }
    }
}

/*****************************************************************************************
**                                                                                      **
*****************************************************************************************/
void print96(const void *data)
{
    const uint8 *bytes = (const uint8 *)data;
    int j;

    for (j = 0; j < 12; j++)
    {
        print_f("%02x", bytes[j]);
        if ((j % 4) == 3)
        {
            print_f(" ");
        }
    }
}
/*****************************************************************************************
**                                                                                      **
*****************************************************************************************/
void print200(const void *data)
{
    const uint8 *bytes = (const uint8 *)data;
    int j;

    for (j = 0; j < 25; j++)
    {
        print_f("%02x", bytes[j]);
        if ((j % 4) == 3)
        {
            print_f(" ");
        }
    }
}
/*****************************************************************************************
**                                                                                      **
*****************************************************************************************/
void print480(const void *data)
{
    const uint8 *bytes = (const uint8 *)data;
    int j;

    for (j = 0; j < 60; j++)
    {
        print_f("%02x", bytes[j]);
        if ((j % 4) == 3)
        {
            print_f(" ");
        }
    }
}
/*****************************************************************************************
**                                                                                      **
*****************************************************************************************/
void print160(const void *data)
{
    const uint8 *bytes = (const uint8 *)data;
    int j;

    for (j = 0; j < 20; j++)
    {
        print_f("%02x", bytes[j]);
        if ((j % 4) == 3)
        {
            print_f(" ");
        }
    }
}
/*****************************************************************************************
**                                                                                      **
*****************************************************************************************/
void print256(const void *data)
{
    const uint8 *bytes = (const uint8 *)data;
    int j;

    for (j = 0; j < 32; j++)
    {
        print_f("%02x", bytes[j]);
        if ((j % 4) == 3)
        {
            print_f(" ");
        }
    }
}
/*****************************************************************************************
**                                                                                      **
*****************************************************************************************/
void print224(const void *data)
{
    const uint8 *bytes = (const uint8 *)data;
    int j;

    for (j = 0; j < 28; j++)
    {
        print_f("%02x", bytes[j]);
        if ((j % 4) == 3)
        {
            print_f(" ");
        }
    }
}
/*****************************************************************************************/

#if SHE_TESTCANCEL
void HsmSheCancelCallbackNotify(void)
{
    HsmSheCancelFlag = HsmSheCancelFlag+1;

    if(CancelRequired == 1)
    {
        ISR_HsmStatus = HsmMcal_GetHsm2HtStatus();
        if(((ISR_HsmStatus & (uint32)HSMCOM_STAT_BUSY) == (uint32)HSMCOM_STAT_BUSY))
        {
 /*           Gpt_StopTimer(Gptch_CancelCommand); */
            Cry_HsmSheCancel();
            CancelRequired = 0;
        }
    }
}
#endif
#define CRY_STOP_SEC_CODE
/*IFX_MISRA_RULE_20_01_STATUS=File inclusion after pre-processor directives is
 allowed only for Cry_MemMap.h*/
#include "Cry_MemMap.h"
